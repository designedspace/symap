<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>SYMAP</title>
        
        <script src="d3.v3.min.js"></script>
        <script src="topojson.v1.min.js"></script>
        <script src="simple_statistics.js"></script>
        <script src="turf.min.js"></script>
        
		<style type="text/css">
            
            body {
                background-color: #000000;
            }
            
            svg .bg {
                pointer-events: all;
            }
            
            svg .intBoundary {
                stroke: white;
                stroke-width: 1px;
                stroke-dasharray: 4,4;
                fill:none;
                opacity: 0.5;
            }
            
            svg .extBoundary {
                stroke: white;
                stroke-width: 2px;
/*                stroke-dasharray: 2,2;*/
                stroke-linejoin: round;
                fill:none;
                opacity: 0.5;
            }
            
            svg .symapFill {
                fill: magenta;
                opacity: 1;
            }
            
            svg text {
                font-family: 'Courier New', Courier, 'Lucida Sans Typewriter', 'Lucida Typewriter', monospace;
                font-weight: normal;
                text-anchor: middle;
            }
		</style>
	</head>
	<body>
        
        <div id="map"></div>
        
		<script type="text/javascript">
            
            var margin = {top: 50, right: 50, bottom: 50, left: 50},
                w = 1920 - margin.right - margin.left,
                h = 1080 - margin.top - margin.bottom,
                bgOpacity = 0.4;
            
            //SYMAP config
            var numClasses = 5,
                gridRes = 4,
                fontSize = gridRes * 2;
            
            //Geo config
            var mapCenter = [-85.76394,37.81914],
                parallels = [36,40],
                scale = 15000;
            

            //GEO-SETUP!

            //Define projection.
            var projection = d3.geo.conicEqualArea()
                .rotate([-mapCenter[0], 0])
                .center([0,mapCenter[1]])
                .parallels(parallels)
                .scale(scale)
                .translate([w / 2, h / 2]);

            //Define path generator.     
            var path = d3.geo.path()
                .projection(projection);
            
            var zoom = d3.behavior.zoom()
                        .translate([0, 0])
                        .scale(1)
                        .scaleExtent([1, 6])
                        .size([w,h])
                        .on("zoom", zoomed);

            //Build map frame.
			var svg = d3.select("#map")
						.append("svg")
						.attr("width", w)
						.attr("height", h);
            
            var features = svg.append("g").attr("class","features");

//            var background = features.append("rect")
//                    .attr("class", "bg")
//                    .style("fill", t)
//                    .attr("width", w)
//                    .attr("height", h)
//                    .attr("opacity", bgOpacity)
//                    .call(zoom);
            
//             Overprinting convention drawn from Mould, R. F., and C. Wyld. 1973. “A Comparison 
//             between Line Printer and Conventional Polaroid Camera Displays Using a Liver 
//             Phantom, Off-Line Computer and Contour Mapping Package.” Physics in Medicine 
//             and Biology 18 (1): 88–99.
            
            var textSymbology = ["•","•+","O•","O•+","OXAV"];
//            var textSymbology = ["-","=","*","#","><","OX","MW","OMW","OXAV"];
            var colorSymbology = ["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"];
            var opaSymbology = [0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.00];
            
            d3.json('kyCountyPops.json', function(error, ky) {

            if (error) return console.error(error);

            svg.call(zoom);

            // LOAD COUNTIES AND PRODUCE CENTROIDS
            var counties = topojson.feature(ky, ky.objects.counties).features;
                
                var centroids = []   
                for(var i = 0; i < counties.length; i++) {
                    centroids[i] = turf.point(turf.center(counties[i]).geometry.coordinates, {"z" : counties[i].properties.population});
                }
                
                
                
                // DETERMINE BOUNDS
                // (TAKES THE FORM [[LAT_MIN,LNG_MIN],[LAT_MAX,LNG_MAX]]
                var kyExtent = d3.geo.bounds(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a === b; }));
                // REFORMAT BOUNDS FOR GENERATING POINT GRID
                // (I.E., [LAT_MIN,LNG_MIN,LAT_MAX,LNG_MAX])
                var kyExtent = [kyExtent[0][0],kyExtent[0][1],kyExtent[1][0],kyExtent[1][1]];
                
                // GENERATE POINT GRID
                // ASSIGN TO VARIABLE O
                var grid = turf.within(turf.pointGrid(kyExtent,gridRes,'kilometers'),turf.featurecollection(counties));

                // COMPUTE TOTAL AREA BY SUMMING COUNTIES
                var kyArea = 0;
                for (i in counties) kyArea += turf.area(counties[i]) / 1000000;
                
                // COMPUTE SEARCH RADIUS (SEE SHEPARD 1968, 519)
                radius = Math.sqrt((7 * kyArea)/(Math.PI *  centroids.length));
                
                var distArray = [];
                var valueArray = [];
//                
                for (i in grid.features) {
                    for (j in centroids) {
                        var dist = turf.distance(grid.features[i],centroids[j],'kilometers');
                        distArray[j] = [dist,centroids[j].properties.z];
                    }
                    
                    distArray.sort(function(a,b) {
                        return a[0] - b[0];
                    });
                    
                    if (distArray[3][0] > radius) {
                        distArray = distArray.slice(0,4);
                    } else if (distArray[3][0] <= radius) {
                        for (var k = 4; k <= 10; k++) {
                            if (distArray[k][0] > radius) {
                                distArray = distArray.slice(0,k+1);
                                break;
                            }
                        }
                    }
                    
                    if (distArray.length > 10) {
                        distArray = distArray.slice(0,10);   
                    }
                    
                    console.log(distArray.length);
//                    distArray = distArray.slice(0,1);
                    
                    var num = 0;
                    var den = 0;
                    var idw;
                    var weight;
                    
//                    Inverse Distance Weighting algorithm drawn from Shepard, Donald. 1968. “A 
//                    Two-Dimensional Interpolation Function for Irregularly-Spaced Data.” In 
//                    Proceedings of the Association for Computing Machinery National Conference, 
//                    517–24.
                    
                    for(feats in distArray) {
                        
                        var d = distArray[feats][0];
                        
                        if ( d > 0 && d <= (radius / 3)) {
                            weight = 1 / d;   
                        } else if ( d > (radius / 3) && (d <= radius)) {
                            weight = (27 / (4 * radius)) * ((d / radius) - 1) * ((d / radius) - 1);   
                        } else if ( d > radius) weight = 0;
                        
                        num += distArray[feats][1] * weight * weight;
                        den += weight * weight;
                    }
                    
                    idw = num/den;
                    
                    if (den != 0) {
                        grid.features[i].properties.z = idw;
                        valueArray.push(idw);
                    } else {
                        grid.features[i].properties.z = 0;
                        valueArray.push(0);
                    }
                    
                }
                
                var breaks = ss.jenks(valueArray, numClasses);
                
                var textShade = d3.scale.quantile()
                    .domain(breaks)
                    .range(textSymbology);
                
                var colorShade = d3.scale.quantile()
                    .domain(breaks)
                    .range(colorSymbology);
                
                var opaShade = d3.scale.quantile()
                    .domain(breaks)
                    .range(opaSymbology);
                
                features.append("g").attr("class","symapFill")
                    .selectAll("text")
                    .data(grid.features)
                    .enter()
                    .append("text")
                    .attr("x", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[0];
                    })
                    .attr("y", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[1];
                    })
                    .attr({
                        "font-size": fontSize,
                        "letter-spacing": -fontSize*0.6
//                        "fill": "#ffffff"
                    })
//                    .attr("fill", function(d) {
//                        return colorShade(d.properties.z);
//                    })
                    .attr("fill-opacity", function(d) {
                        return opaShade(d.properties.z);
                    })
                    .text(function(d) {
                        return textShade(d.properties.z);
                    })
                    .attr("d", path);
                
                features.append("g").attr("class","intBoundary")
                .selectAll("path")
                .data(counties)
                .enter()
                .append("path")
                .attr("d", path);

                features.append("g").attr("class","extBoundary")
                .append("path")
                .datum(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a === b; }))
                .attr("d", path);
            });
            
            d3.json('kyAdjacent.json', function(error, adj) {

                if (error) return console.error(error);

                svg.call(zoom);

                var states = topojson.feature(adj, adj.objects.kyAdjacent).features;

                features.append("g").attr("class","extBoundary")
                    .selectAll("path")
                    .data(states)
                    .enter()
                    .append("path")
                    .attr("d", path);
            });
            
            function zoomed() {
                var e = d3.event;
                var tx = Math.min(0, Math.max(e.translate[0], w - (w * e.scale)));
                var ty = Math.min(0, Math.max(e.translate[1], h - (h * e.scale)));
                
                zoom.translate([tx, ty]);
                
                features.attr("transform", "translate(" + [tx, ty] + ")scale(" + e.scale + ")");
            }
			
		</script>
	</body>
</html>