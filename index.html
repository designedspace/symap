<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>SYMAP</title>
        
        <script src="d3.v3.min.js"></script>
        <script src="topojson.v1.min.js"></script>
        <script src="simple_statistics.js"></script>
        <script src="turf.min.js"></script>
        
		<style type="text/css">
            
            svg .bg {
                pointer-events: all;
            }
            
			svg .symapFill {
                stroke: white;
                stroke-width: 4px;
                stroke-linejoin: round;+
            }
            
            svg .intBoundary {
                stroke: white;
                stroke-width: 0.5px;
                stroke-dasharray: 1,1.5;
                stroke-linejoin: round;
                fill:none;
                opacity: 1;
            }
            
            svg .extBoundary {
                stroke: black;
                stroke-width: 1.5px;
                stroke-dasharray: 2,2;
                stroke-linejoin: round;
                fill:none;
                opacity: 1;
            }
            
            svg .centroid {
                stroke: none;
                fill:yellow;
                opacity: 1;
            }
            
            svg .grid {
                stroke: none;
                fill: black;
                opacity: 1;
            }
            
            svg text {
                font-family: 'Courier New', Courier, 'Lucida Sans Typewriter', 'Lucida Typewriter', monospace;
                font-weight: normal;
                text-anchor: middle;
		</style>
	</head>
	<body>
        
        <div id="map"></div>
        
        <script type = "text/javascript">
//            The following code is modified from textures.js by Riccardo Scalco, licensed under
//            the following MIT license...
            
//            The MIT License (MIT)

//            Copyright (c) 2015 Riccardo Scalco

//            Permission is hereby granted, free of charge, to any person obtaining a copy of this 
//            software and associated documentation files (the "Software"), to deal in the Software 
//            without restriction, including without limitation the rights to use, copy, modify, 
//            merge, publish, distribute, sublicense, and/or sell copies of the Software, and to 
//            permit persons to whom the Software is furnished to do so, subject to the following 
//            conditions:

//            The above copyright notice and this permission notice shall be included in all copies 
//            or substantial portions of the Software.

//            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
//            INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
//            PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
//            FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
//            OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
//            DEALINGS IN THE SOFTWARE.
        
            (function() {
                var rand, umd,
                slice = [].slice;

                rand = function() {
                    return ((Math.random().toString(36)) + "00000000000000000").replace(/[^a-z]+/g, "").slice(0, 5);
                };

                umd = function(factory) {
                    if (typeof exports === 'object') {
                        return module.exports = factory();
                    } else if (typeof define === 'function' && define.amd) {
                        return define([], factory);
                    } else {
                        return this.textures = factory();
                    }
            };

            umd(function() {
                return {
                    symap: function() {
                        var background = "",
                        fontSize = 5;
                        xSize = Math.round(fontSize * 0.7);
                        ySize = Math.round(fontSize * 1.25);
                        fill = "#000000";
                        opacity = 0.85;
                        id = rand();
                        text = ["O","X","A","V"];
                        
                        symap = function() {
                            var corner, g, i, len, ref, results;
                            g = this.append("defs").append("pattern").attr({
                                    id: id,
                                    patternUnits: "userSpaceOnUse",
                                    width: xSize,
                                    height: ySize * 0.65
                                });
                            if (background) {
                                g.append("rect").attr({
                                        width: xSize,
                                        height: ySize,
                                        fill: background
                                    });
                            }
                            for(var i=0; i < text.length; i++) {
                                g.append("text").attr({
                                    x: Math.round(xSize / 2),
                                    y: Math.round(ySize / 2),
                                    "font-size": fontSize,
                                    fill: fill,
                                    "fill-opacity": opacity
                                })
                                .text(text[i]);
                            }
                        };
                        symap.background = function(_) {
                            background = _;
                            return symap;
                        };
                        symap.size = function(_) {
                            size = _;
                            return symap;
                        };
                        symap.fontSize = function(_) {
                            fontSize = _;
                            xSize = Math.round(fontSize * 0.7);
                            ySize = Math.round(fontSize * 1.25);
                            return symap;
                        };
                        symap.fill = function(_) {
                            fill = _;
                            return symap;
                        };
                        symap.kerning = function(_) {
                            kerning = _;
                            return symap;
                        };
                        symap.text = function(_) {
                            text = _;
                            return symap;
                        };
                        symap.id = function(_) {
                            if (!arguments.length) {
                                return id;
                            } else {
                                id = _;
                                return circles;
                            }
                        };
                    symap.url = function() {
                        return "url(#" + id + ")";
                    };
                    return symap;
                    }
                };
            });

            }).call(this);
        </script>
        
		<script type="text/javascript">
            
            var margin = {top: 50, right: 50, bottom: 50, left: 50},
                w = 1200 - margin.right - margin.left,
                h = 600 - margin.top - margin.bottom,
                bgOpacity = 0.4;
            
            //SYMAP config
            var numClasses = 9,
                resolution = 5;
            
            //Geo config
            var mapCenter = [-85.76394,37.81914],
                parallels = [36,40],
                scale = 9000;
            

            //GEO-SETUP!

            //Define projection.
            var projection = d3.geo.conicEqualArea()
                .rotate([-mapCenter[0], 0])
                .center([0,mapCenter[1]])
                .parallels(parallels)
                .scale(scale)
                .translate([w / 2, h / 2]);

            //Define path generator.     
            var path = d3.geo.path()
                .projection(projection);
            
            var zoom = d3.behavior.zoom()
                        .translate([0, 0])
                        .scale(1)
                        .scaleExtent([1, 6])
                        .size([w,h])
                        .on("zoom", zoomed);

            //Build map frame.
			var svg = d3.select("#map")
						.append("svg")
						.attr("width", w)
						.attr("height", h);
            
            var features = svg.append("g").attr("class","features");

            //Set background pattern.
            var t = textures.symap()
              .text("-");

            svg.call(t);

//            var background = features.append("rect")
//                    .attr("class", "bg")
//                    .style("fill", t.url())
//                    .attr("width", w)
//                    .attr("height", h)
//                    .attr("opacity", bgOpacity)
//                    .call(zoom);
            
            // Overprinting convention drawn from Mould, R. F., and C. Wyld. 1973. “A Comparison 
            // between Line Printer and Conventional Polaroid Camera Displays Using a Liver 
            // Phantom, Off-Line Computer and Contour Mapping Package.” Physics in Medicine 
            // and Biology 18 (1): 88–99.

            var symbology = [["-"],["="],["*"],["#"],[">","<"],["O","X"],["M","W"],["O","M","W"],["O","X","A","V"]];
            
            d3.json('kyCountyPops.json', function(error, ky) {
                
                if (error) return console.error(error);
                
                svg.call(zoom);
                
                var counties = topojson.feature(ky, ky.objects.counties).features;
                
                var kyExtent = d3.geo.bounds(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a === b; }));
                var kyExtent = [kyExtent[0][0],kyExtent[0][1],kyExtent[1][0],kyExtent[1][1]];
                var pointGrid = turf.pointGrid(kyExtent,resolution,'kilometers');
                
                console.log(pointGrid);
                
            // generate featureCollection of centroids w/ z-values for isobands input.
                var centroids = []   
                for(var i = 0; i < counties.length; i++) {
                    centroids[i] = turf.point(turf.center(counties[i]).geometry.coordinates, {"z" : counties[i].properties.population});
                }
            // end make featureCollection
                
                console.log(centroids);
                
                var breaks = ss.jenks(counties.map(function(d) { 
                        return +d.properties.population 
                    }), numClasses);
                
                var shade = d3.scale.quantile()
                    .domain(breaks)
                    .range(symbology);
                
//                features.append("g").attr("class","symapFill")
//                    .selectAll("path")
//                    .data(topojson.feature(ky, ky.objects.counties).features)
//                    .enter()
//                    .append("path")
//                    .style("fill", function(d,i) {
//                        var val = shade(d.properties.population);
//
//                        if (val !== undefined) {
//
//                            var t = textures.symap()
//                                .text(val)
//                                .fontSize(resolution)
//                                .background("white");
//
//                            svg.call(t);
//                            return t.url();
//                        }
//                    })
//                    .attr("d", path);
                
                features.append("g").attr("class","centroid")
                    .selectAll("circle")
                    .data(centroids)
                    .enter()
                    .append("circle")
                    .attr("cx", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[1];
                    })
                    .attr("r", 5)
                    .attr("d", path);
                
                features.append("g").attr("class","grid")
                    .selectAll("circle")
                    .data(pointGrid.features)
                    .enter()
                    .append("circle")
                    .attr("cx", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[1];
                    })
                    .attr("r", 1)
                    .attr("d", path);
                
//                features.append("g").attr("class","intBoundary")
//                    .append("path")
//                    .datum(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a !== b; }))
//                    .attr("d", path);
//                
//                features.append("g").attr("class","extBoundary")
//                    .append("path")
//                    .datum(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a === b; }))
//                    .attr("d", path);
            });
            
            function zoomed() {
                var e = d3.event;
                var tx = Math.min(0, Math.max(e.translate[0], w - (w * e.scale)));
                var ty = Math.min(0, Math.max(e.translate[1], h - (h * e.scale)));
                
                zoom.translate([tx, ty]);
                
                features.attr("transform", "translate(" + [tx, ty] + ")scale(" + e.scale + ")");
            }
			
		</script>
	</body>
</html>