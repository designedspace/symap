<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>SYMAP</title>
        
        <script src="http://d3js.org/d3.v3.min.js"></script>
        <script src="http://d3js.org/topojson.v1.min.js"></script>
        <script src="js/simple_statistics.js"></script>
        <script src="//api.tiles.mapbox.com/mapbox.js/plugins/turf/v2.0.0/turf.min.js"></script>
        
		<style type="text/css">
            
            body {
                background-color: #ffffff;
            }
            
            svg .bg {
                pointer-events: all;
            }
            
            svg .intBoundary {
                stroke: #ff0000;
                stroke-width: 0.5px;
                stroke-dasharray: 4,4;
                fill:none;
                opacity: 1;
            }
            
            svg .extBoundary {
                stroke: #ff0000;
                stroke-width: 1px;
/*                stroke-dasharray: 2,2;*/
                stroke-linejoin: round;
                fill:none;
                opacity: 1;
            }
            
            svg .symapFill {
                fill: #ff0000;
                opacity: 1;
            }
            
            svg text {
                font-family: 'Courier New', Courier, 'Lucida Sans Typewriter', 'Lucida Typewriter', monospace;
                font-weight: normal;
                text-anchor: middle;
            }
		</style>
	</head>
	<body>
        
        <div id="map"></div>
        
		<script type="text/javascript">
            
            var margin = {top: 50, right: 50, bottom: 50, left: 50},
                w = 1920 - margin.right - margin.left,
                h = 1080 - margin.top - margin.bottom,
                bgOpacity = 0.4;
            
            //SYMAP config
            var numClasses = 5,
                gridRes = 4,
                fontSize = gridRes * 2,
                symapMode = "conformant",
                kyCounties = 'data/kyCountyPops.json',
                otherStates = 'data/kyAdjacent.json'
            
            //Geo config
            var mapCenter = [-85.76394,37.81914],
                parallels = [36,40],
                scale = 15000;
            

            //GEO-SETUP!

            //Define projection.
            var projection = d3.geo.conicEqualArea()
                .rotate([-mapCenter[0], 0])
                .center([0,mapCenter[1]])
                .parallels(parallels)
                .scale(scale)
                .translate([w / 2, h / 2]);

            //Define path generator.     
            var path = d3.geo.path()
                .projection(projection);
            
            var zoom = d3.behavior.zoom()
                        .translate([0, 0])
                        .scale(1)
                        .scaleExtent([1, 6])
                        .size([w,h])
                        .on("zoom", zoomed);

            //Build map frame.
			var svg = d3.select("#map")
						.append("svg")
						.attr("width", w)
						.attr("height", h);
            
            var features = svg.append("g").attr("class","features");
            
//             Overprinting convention drawn from Mould, R. F., and C. Wyld. 1973. “A Comparison 
//             between Line Printer and Conventional Polaroid Camera Displays Using a Liver 
//             Phantom, Off-Line Computer and Contour Mapping Package.” Physics in Medicine 
//             and Biology 18 (1): 88–99.
            
            var textSymbology = ["•","•+","O•","O•+","OXAV"];
//            var textSymbology = ["-","=","*","#","><","OX","MW","OMW","OXAV"];
//            var colorSymbology = ["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"];
            
            d3.json(kyCounties, function(error, ky) {

            if (error) return console.error(error);

            svg.call(zoom);

            // LOAD COUNTIES AND PRODUCE CENTROIDS
            var counties = topojson.feature(ky, ky.objects.counties).features;
                
                
                
                // DETERMINE BOUNDS
                // (TAKES THE FORM [[LAT_MIN,LNG_MIN],[LAT_MAX,LNG_MAX]]
                var kyExtent = d3.geo.bounds(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a === b; }));
                // REFORMAT BOUNDS FOR GENERATING POINT GRID
                // (I.E., [LAT_MIN,LNG_MIN,LAT_MAX,LNG_MAX])
                var kyExtent = [kyExtent[0][0],kyExtent[0][1],kyExtent[1][0],kyExtent[1][1]];
                
                // GENERATE POINT GRID
                // ASSIGN TO VARIABLE O
                var grid = turf.within(turf.pointGrid(kyExtent,gridRes,'kilometers'),turf.featurecollection(counties));
                
                var valueArray = [];
                
                if (symapMode == "conformant") {
                    for (i in grid.features) {
                        for (j in counties) {
                            if (turf.inside(grid.features[i],counties[j])) {
                                grid.features[i].properties.z = counties[j].properties.population;
                                valueArray[i] = counties[j].properties.population;
                                break;
                            }
                        }
                    }
                } else if (symapMode == "contour") {
                
                    var centroids = [];
                    for(var i = 0; i < counties.length; i++) {
                        centroids[i] = turf.point(
                            turf.center(counties[i]).geometry.coordinates, 
                            {"z" : counties[i].properties.population}
                        );
                    }
                    centroids = turf.featurecollection(centroids);

                    // COMPUTE TOTAL AREA BY SUMMING COUNTIES
                    var kyArea = 0;
                    for (i in counties) kyArea += turf.area(counties[i]) / 1000000;

                    // COMPUTE SEARCH RADIUS (SEE SHEPARD 1968, 519)
                    radius = Math.sqrt((7 * kyArea)/(Math.PI *  centroids.features.length));

                    var distArray = [];
    //                
                    for (i in grid.features) {
                        for (j in centroids.features) {
                            var dist = turf.distance(grid.features[i],centroids.features[j],'kilometers');
                            distArray[j] = [dist,centroids.features[j].properties.z];
                        }

                        distArray.sort(function(a,b) {
                            return a[0] - b[0];
                        });

                        if (distArray[3][0] > radius) {
                            distArray = distArray.slice(0,4);
                        } else if (distArray[3][0] <= radius) {
                            for (var k = 4; k <= 10; k++) {
                                if (distArray[k][0] > radius) {
                                    distArray = distArray.slice(0,k+1);
                                    break;
                                }
                            }
                        }

                        if (distArray.length > 10) {
                            distArray = distArray.slice(0,10);   
                        }

                        var num = 0;
                        var den = 0;
                        var idw;
                        var weight;

    //                    Inverse Distance Weighting algorithm drawn from Shepard, Donald. 1968. “A 
    //                    Two-Dimensional Interpolation Function for Irregularly-Spaced Data.” In 
    //                    Proceedings of the Association for Computing Machinery National Conference, 
    //                    517–24.

                        for(feats in distArray) {

                            var d = distArray[feats][0];

                            if ( d > 0 && d <= (radius / 3)) {
                                weight = 1 / d;   
                            } else if ( d > (radius / 3) && (d <= radius)) {
                                weight = (27 / (4 * radius)) * ((d / radius) - 1) * ((d / radius) - 1);   
                            } else if ( d > radius) weight = 0;
                            num += distArray[feats][1] * weight * weight;
                            den += weight * weight;
                        }

                        idw = num/den;

                        if (den != 0) {
                            grid.features[i].properties.z = idw;
                            valueArray.push(idw);
                        } else {
                            grid.features[i].properties.z = 0;
                            valueArray.push(0);
                        }
                    }
                }
            
                var breaks = ss.jenks(valueArray, numClasses);
                
                var textShade = d3.scale.quantile()
                    .domain(breaks)
                    .range(textSymbology);
                
//                var colorShade = d3.scale.quantile()
//                    .domain(breaks)
//                    .range(colorSymbology);
                
                features.append("g").attr("class","symapFill")
                    .selectAll("text")
                    .data(grid.features)
                    .enter()
                    .append("text")
                    .attr("x", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[0];
                    })
                    .attr("y", function(d) {
                        return projection([d.geometry.coordinates[0], d.geometry.coordinates[1]])[1];
                    })
                    .attr({
                        "font-size": fontSize,
                        "letter-spacing": -fontSize*0.6
//                        "fill": "#ffffff"
                    })
//                    .attr("fill", function(d) {
//                        return colorShade(d.properties.z);
//                    })
//                    .attr("fill-opacity", function(d) {
//                        return opaShade(d.properties.z);
//                    })
                    .text(function(d) {
                        return textShade(d.properties.z);
                    })
                    .attr("d", path);
                
                features.append("g").attr("class","intBoundary")
                    .append("path")
                    .datum(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a !== b; }))
                    .attr("d", path);
//
//                features.append("g").attr("class","extBoundary")
//                .append("path")
//                .datum(topojson.mesh(ky, ky.objects.counties, function(a, b) { return a === b; }))
//                .attr("d", path);
            });
            
            d3.json(otherStates, function(error, adj) {

                if (error) return console.error(error);

                svg.call(zoom);

                var states = topojson.feature(adj, adj.objects.kyAdjacent).features;

                features.append("g").attr("class","extBoundary")
                    .selectAll("path")
                    .data(states)
                    .enter()
                    .append("path")
                    .attr("d", path);
            });
            
            function zoomed() {
                var e = d3.event;
                var tx = Math.min(0, Math.max(e.translate[0], w - (w * e.scale)));
                var ty = Math.min(0, Math.max(e.translate[1], h - (h * e.scale)));
                
                zoom.translate([tx, ty]);
                
                features.attr("transform", "translate(" + [tx, ty] + ")scale(" + e.scale + ")");
            }
			
		</script>
	</body>
</html>